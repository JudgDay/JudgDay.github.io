<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BigDecimal解决Non-terminating decimal expansion no exact representable decimal result问题]]></title>
    <url>%2F2025%2F06%2F29%2FBigDecimal%E8%A7%A3%E5%86%B3Non-terminating-decimal-expansion-no-exact-representable-decimal-result%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[BigDecimal解决Non-terminating decimal expansion no exact representable decimal result问题问题描述使用BigDecimal.divide()报java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result异常 问题原因BigDecimal.divide()的商的小数无限循环导致的 12345public static void main(String[] args) &#123; BigDecimal one = new BigDecimal(1); BigDecimal three = new BigDecimal(3); System.out.println(one.divide(three));&#125; 解决方法设置商的小数点位数和舍入规则 123456public static void main(String[] args) &#123; BigDecimal one = new BigDecimal(1); BigDecimal three = new BigDecimal(3); //取四位小数，四舍五入 System.out.println(one.divide(three, 4, RoundingMode.HALF_UP)));&#125;]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown解决表格中竖线自动转义问题]]></title>
    <url>%2F2023%2F10%2F13%2FMarkdown%E8%A7%A3%E5%86%B3%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%AB%96%E7%BA%BF%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Markdown解决表格中竖线自动转义问题问题描述在Markdown的表格中输入|，会被自动转义 问题原因由于Markdown的表格是通过|来定义，因此不能直接用|来写绝对值或竖杠，所以会被自动转义 解决方法用&amp;#124;或&amp;#x7C;替代|]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat解决Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986问题]]></title>
    <url>%2F2023%2F10%2F12%2FTomcat%E8%A7%A3%E5%86%B3Invalid-character-found-in-the-request-target-The-valid-characters-are-defined-in-RFC-7230-and-RFC-3986%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Tomcat解决Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986问题问题描述Tomcat运行项目中出现Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986错误 问题原因Tomcat7.0之后的版本按照RFC 3986规范进行访问解析，Url中只允许包含英文字母(a-zA-Z)、数字(0-9)、特殊字符(- _ . ~)、保留字符(! * &#39; ( ) ; : @ &amp; = + $ , / ? # [ ]) 解决方法 更换低版本Tomcat 修改Tomcat的server文件 修改Tomcat目录下的/conf/server.xml文件，在&lt;Connector&gt;标签中添加relaxedQueryChars=&quot;[]|{}^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot;属性 对特殊字符进行转义 字符 描述 编码 ; 分号 %3B / 斜线 %2F ? 问号 %3F : 冒号 %3A @ “at”符号 %4O = 等号 %3D &amp; “和”符号 %26 &lt; 小于号 %3C &gt; 大于号 %3E “ 双引号 %22 # 井号 %23 % 百分号 %25 { 左大括号 %7B } 右大括号 %7D &#124; 竖线 %7C \ 反斜线 %5C ^ 加字号 %5E ~ 波浪号 %7E [ 左中括号 %5B ] 右中括号 %5D ` 反单引号 %60 空格 %20]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot解决mapping values are not allowed here in 'reader'问题]]></title>
    <url>%2F2023%2F10%2F12%2FSpringBoot%E8%A7%A3%E5%86%B3mapping-values-are-not-allowed-here-in-reader-%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SpringBoot解决mapping values are not allowed here in ‘reader’问题问题描述启动SpringBoot项目时出现mapping values are not allowed here in &#39;reader&#39;错误 问题原因yml文件的格式不正确，注意以下几点： 冒号是否是半角 冒号后面是否有空格 属性的缩进是否正确]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FinalShell自动执行set +o history命令]]></title>
    <url>%2F2023%2F10%2F07%2FFinalShell%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8Cset-o-history%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[FinalShell自动执行set +o history命令问题描述FinalShell终端连接后自动执行set +o history命令 问题原因FinalShell的服务器监控功能需要不停调用系统命令来获取系统信息，可能会生成大量命令历史记录，影响正常使用，因此FinalShell自动关闭命令历史记录功能]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>FinalShell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA解决Since Maven 3.8.1 http repositories are blocked问题]]></title>
    <url>%2F2023%2F10%2F07%2FIDEA%E8%A7%A3%E5%86%B3Since-Maven-3-8-1-http-repositories-are-blocked%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[IDEA解决Since Maven 3.8.1 http repositories are blocked问题问题描述IDEA下载引用的依赖时出现了Since Maven 3.8.1 http repositories are blocked错误 问题原因从Maven 3.8.1开始，Maven不再支持http的依赖 解决办法 降低Maven版本 在IDEA的Settings中搜索Maven，将Maven home path地址改成3.8.1以下版本即可。 升级依赖 在pom.xml文件中将报错的依赖版本升级 修改Maven参数 在Maven命令中添加-Dmaven.wagon.http.allowAll=true参数来允许HTTP请求]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装MySQL]]></title>
    <url>%2F2023%2F09%2F11%2FLinux%E5%AE%89%E8%A3%85MySQL%2F</url>
    <content type="text"><![CDATA[Linux安装MySQL下载安装包MySQL官网下载地址 根据Linux操作系统版本下载正确的安装包 安装选择一个目录，将安装包上传至该目录1cd /usr/local/ 安装MySQL包1yum -y install mysql80-community-release-el7-10.noarch.rpm 安装MySQL1yum -y install mysql-community-server 如果执行命令过程中提示：Unable to find a match: mysql-community-server，执行以下命令 1yum module disable mysql 设置权限通过chown命令改变文件的拥有者和群组-R：处理指定目录以及其子目录下的所有文件 1chown mysql:mysql -R /var/lib/mysql/ 启动MySQL服务1service mysqld start 查看MySQL运行状态1service mysqld status 看见running就表示启动成功了 查看初始密码1grep 'password' /var/log/mysqld.log 如果能正常查看到，则OK。如果查看不到，则表示没有密码 进入数据库1mysql -u root -p 输入命令后回车，会让你输入密码，如果没有密码，直接回车即可 如果显示数据库无法访问 停止MySQL服务1service mysqld stop 编辑配置文件1vi /etc/my.cnf 添加skip-grant-tables 添加skip-grant-tables，这样MySQL可以免密登录。 再次启动MySQL服务1service mysqld start 再次登录MySQL就可以进入了1mysql -u root -p 切换mysql数据库1use mysql; 更改密码12345678910# 更改密码，XXX为设置的密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'XXX';# 一般执行完上面一句会报如下错误# ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement# 在mysql中输入flush privileges重新加载MySQL权限信息flush privileges;# 再次更改密码，XXX为设置的密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'XXX';# 退出MySQLexit; 修改配置文件，删除skip-grant-tables123456# 停止MySQL服务service mysqld stop# 修改配置文件，删除skip-grant-tablesvi /etc/my.cnf# 开启MySQL服务service mysqld start 使用新密码即可登录 注意如果访问MySQL数据库失败，则记得看下下面三个配置是否OK 服务器的防火墙是否开放MySQL端口33061234567891011121314# 查看firewalld状态，若是dead状态，即防火墙未开启systemctl status firewalld# 查看防火墙是否开放3306端口firewall-cmd --query-port=3306/tcp# 设置3306端口为永久开放firewall-cmd --add-port=3306/tcp --permanent# 关闭防火墙systemctl stop firewalld# 开启防火墙systemctl start firewalld 如果是云服务器，查看云安全组规则是否开放了3306端口不在同一局域网内连接，需要授权远程用户登录若提示Host is not allowed to connect to this MySQL server则需要授权远程用户登录 12345678910# 登录MySQLmysql -u root -p# 切换mysql数据库use mysql;# 授权远程用户登录update user set host = '%' where user = 'root';# 重新加载MySQL权限信息flush privileges;# 退出MySQLexit;]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装JDK并配置环境变量]]></title>
    <url>%2F2023%2F09%2F10%2FLinux%E5%AE%89%E8%A3%85JDK%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Linux安装JDK并配置环境变量下载JDKJDK官网下载地址 选择JDK版本后根据Linux操作系统位数下载正确的安装包 现在下载JDK安装包需要注册Oracle账号 安装1234# 选择一个目录，将安装包上传至该目录cd /usr/local/# 解压安装包tar -zxvf jdk-8u381-linux-x64.tar.gz 配置环境变量修改配置文件 1vi /etc/profile 将下面内容粘贴到末尾，并保存 123export JAVA_HOME=/usr/local/jdk1.8.0_381export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 重新加载配置文件 1source /etc/profile 验证安装输入java -version命令，若出现jdk版本号，则安装成功]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux更改密码]]></title>
    <url>%2F2023%2F09%2F10%2FLinux%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Linux更改密码 输入passwd命令 输入新的密码，回车 重新输入新的密码，回车 提示所有的身份验证令牌已成功更新，则更改成功]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决移动硬盘无法读取问题]]></title>
    <url>%2F2023%2F09%2F10%2F%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决移动硬盘无法读取问题情况移动硬盘连接电脑后无法识别，但仍可以听到移动硬盘连接上的声音，并且移动硬盘转动声音正常，手触摸有震动感，移动硬盘的指示灯正常，打开我的电脑，也可以看到显示出移动硬盘的盘符，但就是无法打开。 原因在移动硬盘运行时，没有点击右下角的安全移除移动硬盘，在硬盘运行的时候直接拔掉导致硬盘无法读取。最好把移动硬盘所有程序停止并安全移除后，再拔掉移动硬盘。 解决方法 移动硬盘连接电脑 查看移动硬盘的卷标 打开cmd 输入chkdsk H:/f (H为移动硬盘卷标) 等待运行完成，就可以正常读取了]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>移动硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac解决重启后环境变量失效问题]]></title>
    <url>%2F2023%2F09%2F10%2FMac%E8%A7%A3%E5%86%B3%E9%87%8D%E5%90%AF%E5%90%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Mac解决重启后环境变量失效问题问题描述Mac配置完环境变量，每次重启后都失效，需要重新执行source ~/.bash_profile命令 问题原因因为是在bash中配置的环境变量，而Mac使用的shell是Zsh 解决办法1234# 编辑.zshrc文件vim ~/.zshrc# 在末尾加入生效配置文件命令，保存后重启source ~/.bash_profile]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot计算汉字相似度]]></title>
    <url>%2F2023%2F09%2F10%2FSpringBoot%E8%AE%A1%E7%AE%97%E6%B1%89%E5%AD%97%E7%9B%B8%E4%BC%BC%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[SpringBoot计算汉字相似度引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.houbb&lt;/groupId&gt; &lt;artifactId&gt;nlp-hanzi-similar&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; 计算相似度123public static void main(String[] args) &#123; System.out.println(HanziSimilarHelper.similar('末', '未'));&#125; 相似汉字123public static void main(String[] args) &#123; System.out.println(HanziSimilarHelper.similarList('爱'));&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot汉字转拼音]]></title>
    <url>%2F2023%2F07%2F30%2FSpringBoot%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8B%BC%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[SpringBoot汉字转拼音引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.hankcs&lt;/groupId&gt; &lt;artifactId&gt;hanlp&lt;/artifactId&gt; &lt;version&gt;portable-1.8.3&lt;/version&gt;&lt;/dependency&gt; 使用汉字转拼音123456import org.apache.commons.collections4.ListUtils;public static void main(String[] args) &#123; List&lt;Pinyin&gt; pinyins = PinyinDictionary.convertToPinyin("重庆"); ListUtils.emptyIfNull(pinyins).forEach(v-&gt; System.out.print(v.getPinyinWithoutTone()));&#125; 汉字首字母123456import org.apache.commons.collections4.ListUtils;public static void main(String[] args) &#123; List&lt;Pinyin&gt; pinyins = PinyinDictionary.convertToPinyin("重庆"); ListUtils.emptyIfNull(pinyins).forEach(v-&gt; System.out.print(v.getFirstChar()));&#125; 汉字符号音调123456import org.apache.commons.collections4.ListUtils;public static void main(String[] args) &#123; List&lt;Pinyin&gt; pinyins = PinyinDictionary.convertToPinyin("重庆"); ListUtils.emptyIfNull(pinyins).forEach(v-&gt; System.out.print(v.getPinyinWithToneMark()));&#125; 汉字数字音调123456import org.apache.commons.collections4.ListUtils;public static void main(String[] args) &#123; List&lt;Pinyin&gt; pinyins = PinyinDictionary.convertToPinyin("重庆"); ListUtils.emptyIfNull(pinyins).forEach(v-&gt; System.out.print(v));&#125; 汉字声母123456import org.apache.commons.collections4.ListUtils;public static void main(String[] args) &#123; List&lt;Pinyin&gt; pinyins = PinyinDictionary.convertToPinyin("重庆"); ListUtils.emptyIfNull(pinyins).forEach(v-&gt; System.out.print(v.getShengmu()));&#125; 汉字音调123456import org.apache.commons.collections4.ListUtils;public static void main(String[] args) &#123; List&lt;Pinyin&gt; pinyins = PinyinDictionary.convertToPinyin("重庆"); ListUtils.emptyIfNull(pinyins).forEach(v-&gt; System.out.print(v.getTone()));&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 413错误解决方法]]></title>
    <url>%2F2023%2F07%2F30%2FHTTP-413%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[HTTP 413错误解决方法原因由于上传文件过大引起的，排查服务器是否有使用nginx做反向代理 解决方法修改nginx配置文件，调整客户端请求大小和缓存大小 12345http &#123; client_max_body_size 10M; client_body_buffer_size 128k; fastcgi_intercept_errors on;&#125; client_max_body_size: 客户端请求服务器最大允许大小，默认1M。如果请求的正文数据大于client_max_body_size，HTTP协议会报413 Request Entity Too Large。 client_body_buffer_size: nginx分配给请求数据的Buffer大小，如果请求的数据小于client_body_buffer_size则将数据先在内存中存储。如果请求的值大于client_body_buffer_size小于client_max_body_size，就会将数据先存储到临时文件中。 client_body_temp: 临时文件存储位置，默认/tmp/。配置的client_body_temp地址一定让执行的nginx的用户组有读写权限。否则，当传输的数据大于client_body_buffer_size，写进临时文件失败会报错。 120648 open() "/usr/local/openresty-1.9.7.5/nginx/client_body_temp/0000000019" failed (13: Permission denied)]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>HTTP Status Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之find命令]]></title>
    <url>%2F2023%2F07%2F30%2FLinux%E4%B9%8Bfind%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux之find命令find 命令用于在指定的目录下搜索目录和文件。可根据文件名、文件类型、文件大小、修改时间等条件进行筛选。 基本语法1find 目录路径 [选项参数] [搜索条件] 目录路径：指定要查找的目录路径。 选项参数：用于指定匹配条件，例如文件名、类型。 搜索条件：用于指定要搜索的文件和目录，满足这个条件的就会被搜索出来。 选项参数-name按文件名进行匹配 12# 搜索后缀为txt的文件find / -name "*.txt" -type按文件类型进行匹配 d: 目录、f: 文件、l: 符号链接（软链接） 12# 搜索文件类型为目录的文件find / -type d -size按文件大小进行匹配 + : 大于、- ：小于 单位: c（字节）、w（字数）、b（块数）、k（KB）、M（MB）、 G（GB） 12# 搜索大于100KB的文件find / -size +100c -user按文件所属用户进行匹配。 12# 搜索属于root用户的文件find / -user root -mtime按文件最后内容的修改时间进行匹配 + : 几天之内、- : 几天之前 单位: 天 12# 搜索修改日期为7天前的文件find / -mtime -7 -perm按文件权限进行匹配 /u: 当前用户、/g: 组权限、/o: 其他用户权限、/a: 所有用户权限 + : 具有、- : 不具有 r: 读权限、w: 写权限、x: 执行权限 12# 查找具有读写权限的文件find / -perm /u+rw -exec对搜索的结果执行命令 12# 将后缀为txt的文件删除find / -name "*.txt" -exec rm &#123;&#125; \; {}为占位符，将搜索的结果放到这里 -exec 参数需要使用 \; 作为命令的结尾]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot事务回滚]]></title>
    <url>%2F2023%2F07%2F30%2FSpringBoot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%2F</url>
    <content type="text"><![CDATA[SpringBoot事务回滚在开发过程中有时会遇到，多次操作数据时，某次操作出现问题导致程序终止，但是之前的数据已经操作，需要回滚使数据复原。基于这种情况，SpringBoot提供了一个注解@Transactional，帮助回滚事务。 原理在应用系统调用声明了@Transactional的目标方法时，Spring Framework 默认使用AOP代理，在代码运行时生成一个代理对象，根据@Transactional的属性配置信息，这个代理对象决定该声明 @Transactional 的目标方法是否由拦截器TransactionInterceptor来使用拦截，在TransactionInterceptor拦截时，会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑，最后根据执行情况是否出现异常，利用抽象事务管理器AbstractPlatformTransactionManager操作数据源DataSource提交或回滚事务。 开启事务启动类加上@EnableTransactionManagement注解，开启事务支持。 SpringBoot默认开启事务，直接在接口、类、方法上使用@Transactional注解即可。 自动回滚1234567@Override@Transactionalpublic void submit() &#123; success(); //假如error()会抛出异常，则success()对数据库的操作会回滚。 error();&#125; 手动回滚1234567891011121314@Override@Transactional(rollbackFor = Exception.class)public String submit()&#123; success(); try &#123; exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 手动回滚事务 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); return "error"; &#125; return "success";&#125; 部分回滚12345678910111213141516@Override@Transactional(rollbackFor = Exception.class)public String submit()&#123; success(); //只回滚以下异常 Object savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint(); try &#123; exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 手动回滚事务 TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint); return ApiReturnUtil.error(); &#125; return ApiReturnUtil.success();&#125; @Transactional参数 参数名称 描述 readOnly 用于设置当前事务是否为只读事务。true表示只读，false则表示可读写，默认为false。例如：@Transactional(readOnly=true) rollbackFor 用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。默认为非检测性异常unchecked exceptions(RuntimeException和Error)。例如：指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class}) transactionManager / value 多个事务管理器托管在Spring容器中时，指定事务管理器的bean名称 rollbackForClassName 用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称：@Transactional(rollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”, “Exception”}) noRollbackFor 用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class}) noRollbackForClassName 用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(noRollbackForClassName={“RuntimeException”, “Exception”}) propagation 用于设置事务的传播行为。默认为REQUIRED。例如：@Transactional(propagation=Propagation.NOT_SUPPORTED, readOnly=true) isolation 用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置。 timeout 用于设置事务的超时秒数。单位为秒，-1表示永不超时，默认为-1。例如：@Transactional(timeout=30) @Propagation参数（事务的传播行为） 参数 描述 REQUIRED 默认的传播行为。如果有事务，则加入事务。没有事务，则新建事务 SUPPORTS 如果有事务，则加入事务。没有事务，则不用事务 MANDATORY 必须在一个已有的事务中执行。如果当前存在事务，则加入该事务，如果当前不存在事务，则抛出异常 REQUIRES_NEW 不管是否存在事务，都新建事务执行。如果已有事务，则挂起当前事务，再新建事务，新的执行完毕, 再执行老的事务 NOT_SUPPORTED 必须在一个没有的事务中执行，如果当前已有事务，则将当前事务挂起 NEVER 必须在一个没有的事务中执行，否则抛出异常IllegalTransactionStateException @isolation参数（事务的隔离级别） 参数 描述 DEFAULT 默认的隔离级别。使用数据库默认的事务隔离级别。MYSQL默认隔离级别为REPEATABLE_READ，Oracle 默认隔离级别为READ_COMMITTED，SQLSERVER默认隔离级别为READ_COMMITTED READ_UNCOMMITTED（读取未提交数据(） 最低的隔离级别。在事务完成前，其他事务可以看到该事务所修改的数据。而在其他事务提交前，该事务也可以看到其他事务所做的修改。可能导致脏读，幻读，不可重复读 READ_COMMITTED（读取已提交数据） 大多数数据库的默认级别。在事务完成前，其他事务无法看到该事务所修改的数据。在该事务提交后，你就可以查看其他事务插入或更新的数据。如果其他事务修改了数据，就会看到不同的数据。可防止脏读，但幻读和不可重复读仍可以发生 REPEATABLE_READ（可重复读） 比READ_COMMITTED更严格，该隔离级别确保如果在事务中查询了某个数据集，你至少还能再次查询到相同的数据集，即使其他事务修改了所查询的数据。然而如果其他事务插入了新数据，你就可以查询到该新插入的数据。可防止脏读，不可重复读，但幻读仍可能发生 SERIALIZABLE（串行化） 完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。代价最大、可靠性最高的隔离级别。所有的事务都是按顺序一个接一个地执行。避免所有不安全读取 注意 @Transactional注解只能被应用到public方法上，对于其它的方法，标记了@Transactional注解也不会报错，但事务无法回滚。 外部调用的公共方法A未声明事务@Transactional，方法B若是其他类的方法且声明事务，则事务由子方法B控制。 外部调用的公共方法A未声明事务@Transactional，子方法B若是本类的方法，则无论子方法B是否声明事务，事务均不会生效。（可以使用applicationContext.getBean(service.class)直接从IOC容器中将类取出来，然后再调用方法B即可，这样就能用上Spring AOP生成的代理对象） 外部调用的公共方法A声明事务@Transactional，无论子方法B是不是本类的方法或者是否声明事务，事务均由公共方法A控制。 异常被try/catch捕获而没有被抛出，则事务无法回滚。 多线程下事务管理因为线程不属于spring托管，所以事物无法回滚。 数据库要支持事务，如果是mysql，要使用innodb引擎，myisam不支持事务。]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit Message规范]]></title>
    <url>%2F2023%2F07%2F30%2FGit-Commit-Message%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Git Commit Message规范格式12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 提交信息包含三个部分header(type、scope、subject)、body和footer，用空行分隔。每个部分不能超过100个字符。 header: 必填，且必须符合header格式。 body: 可填，详细描述提交的内容，可以分为多行。 footer: 可填，其他备注, 一般用于不兼容更新或关闭issue。 headerheader包括三个部分：type（必填）、scope（可填）和subject（必填）。 typetype: commit 类型，有业内常用的字段，也可以根据需要自己定义。 类型 描述 feat 增加新功能 fix 修复问题/BUG docs 文档/注释 style 代码风格相关无影响运行结果的 refactor 重构 test 测试相关 chore 构建过程或辅助工具的变动 scopescope: commit影响的范围, 比如某某组件、某某页面。 subjectsubject: 简短描述提交的内容。]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot重试机制]]></title>
    <url>%2F2023%2F07%2F30%2FSpringBoot%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot重试机制spring-retry是SpringFramework中的一个模块，使用它可以向代码添加重试逻辑。在spring-retry中，所有配置都是基于简单注释的，在方法上添加@Retryable即可。 引入依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 开启只有启用@EnabelRetry才行，写在配置类、启动类或services上都可以。 1234567import org.springframework.context.annotation.Configuration;import org.springframework.retry.annotation.EnableRetry;@Configuration@EnableRetrypublic class RetryConfig &#123;&#125; 使用123456789101112131415@Service@EnableRetrypublic class TestRetryServiceImpl implements TestRetryService &#123; @Override @Retryable(value = Exception.class,maxAttempts = 4,backoff = @Backoff(delay = 2000,multiplier = 1.5)) public int test(int code) throws Exception &#123; System.out.println("test开始" + LocalTime.now()); if (code == 0)&#123; throw new Exception("test"); &#125; System.out.println("test结束" + LocalTime.now()); return 200; &#125;&#125; @Retryable参数 参数 描述 value 指定重试的异常，默认为空。include的同义词，如果excludes也为空，则重试所有异常 include 指定重试的异常，默认为空 exclude 指定不重试的异常，默认为空 maxAttempts 最大重试次数，默认3次 backoff 重试等待策略，默认使用@Backoff @Backoff参数 参数 描述 value 重试间隔时间，单位毫秒，默认1000 multiplier 重试间隔时间倍数，默认为0。若value为2，multiplier为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒 回调当重试耗尽后，可以使用@Recover注解，使RetryOperations传递给一个回调方法，即RecoveryCallback。用于@Retryable重试失败后的处理方法。如果不需要回调方法，可以不写回调方法。 12345@Recoverpublic int recover(Exception e, int code) &#123; System.out.println("回调方法执行！！！！"); return 400;&#125; 注意 重试耗尽后，如果还没成功符合业务判断，则抛出异常。 回调方法与重试方法需写在同一个实现类里。 回调方法的返回值必须与重试方法一致。 回调方法的第一个参数，必须是Throwable类型。 重试方法内不能使用try catch，只能往外抛异常 由于spring-retry用到了aspect增强，所以在类里自调用重试方法会失效。]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker修改RabbitMQ密码]]></title>
    <url>%2F2023%2F07%2F30%2FDocker%E4%BF%AE%E6%94%B9RabbitMQ%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Docker修改RabbitMQ密码1234# 进入rabbitmq的容器docker exec -it 容器ID bash# 修改rabbitmq密码rabbitmqctl change_password 账户 '密码']]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac切换JDK版本]]></title>
    <url>%2F2023%2F07%2F30%2FMac%E5%88%87%E6%8D%A2JDK%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Mac切换JDK版本首先安装各个版本的jdk，安装教程略过，三个版本最终安装目录如下，版本号根据情况略有不同 通过以下明亮可以 1/usr/libexec/java_home -V 123JDK1.6: /Library/Java/JavaVirtualMachines/1.6.0.jdkJDK1.8: /Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdkJDK20: /Library/Java/JavaVirtualMachines/jdk-20.jdk 安装jdk后，编辑bash_profile 1vim ~/.bash_profile 添加如下内容 1234567891011export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`export JAVA_20_HOME=`/usr/libexec/java_home -v 20`#默认设为JDK1.8export JAVA_HOME=$JAVA_8_HOME#设置alias命令动态切换JDK版本alias jdk6="export JAVA_HOME=$JAVA_6_HOME"alias jdk8="export JAVA_HOME=$JAVA_8_HOME"alias jdk20="export JAVA_HOME=$JAVA_20_HOME" 执行生效命令 1source ~/.bash_profile 之后只需在终端中输入alias命令就可以切换jdk版本 1jdk20]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac重启后环境变量失效问题]]></title>
    <url>%2F2023%2F07%2F30%2FMac%E9%87%8D%E5%90%AF%E5%90%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Mac重启后环境变量失效问题1234# 编辑.zshrc文件vim ~/.zshrc# 在文件末尾加入生效配置文件命令，保存后重启source ~/.bash_profile]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker设置Redis密码]]></title>
    <url>%2F2023%2F07%2F30%2FDocker%E8%AE%BE%E7%BD%AERedis%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Docker设置Redis密码12345678910# 进入redis的容器docker exec -it 容器ID bash# 进入redis目录cd /usr/local/bin# 运行命令redis-cli# 查看现有的redis密码config get requirepass# 设置redis密码config set requirepass 密码]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker查看容器IP]]></title>
    <url>%2F2023%2F01%2F26%2FDocker%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8IP%2F</url>
    <content type="text"><![CDATA[Docker查看容器IP1docker inspect 容器ID IPAddress就是容器IP]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL设置不区分表名大小写]]></title>
    <url>%2F2021%2F12%2F06%2FMySQL%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%8C%BA%E5%88%86%E8%A1%A8%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%2F</url>
    <content type="text"><![CDATA[MySQL设置不区分表明大小写MySQL创建环境时没有要求表名称不区分大小写，若期望表名不再区分大小写，需修改lower_case_table_names参数并重启服务。另外要注意，该参数修改会导致之前大写存储的表将无法识别，需要特殊处理。 Linux进入/etc目录 1cd /etc/ 编辑my.cnf文件 1vi my.cnf 在文件最后一行加上 1lower_case_table_names = 1 重启MySQL 1service mysqld restart Windows到MySQL的安装目录下，修改my.ini文件，在文件最后一行加上 1lower_case_table_names=1 重启MySQL]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo绑定域名]]></title>
    <url>%2F2021%2F12%2F05%2FHexo%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Hexo绑定域名查询Hexo博客Github Pages域名的IP在终端或者命令行中输入以下命令 1ping yourname.github.io 就可以获取到Github Pages域名的IP 域名解析打开阿里云控制台，点击左侧菜单中的域名 进入域名管理页面，可以看到之前购买的域名在列表里，点击解析 进入解析页面，点击添加记录 在域名解析设置里添加两条记录 主机记录就是域名的前缀，常见的用法有 主机记录 描述 www 解析后的域名为www.aliyun.com @ 直接解析主域名 aliyun.com * 泛解析，匹配其他所有域名 *.aliyun.com mail 将域名解析为mail.aliyun.com，通常用于解析邮箱服务器 二级域名 如：abc.aliyun.com，填写abc 手机网站 如：m.aliyun.com，填写m 显性URL 不支持泛解析（泛解析：将所有子域名解析到同一地址） 新建CNAME文件进入本地hexo中source目录下，新建名为CNAME的文件，不要任何后缀，在文件中输入 1zmjwdzjl.com 可以填写www.zmjwdzjl.com 和 zmjwdzjl.com 两种访问方式，但如果填写 www.zmjwdzjl.com 则只支持 www.zmjwdzjl.com 一种访问方式，如果是中文域名的话，则需先将中文域名转换为Punycode标准编码的字符串，再填入CNAME文件即可 然后在Hexo项目目录下执行以下命令重新部署hexo 123hexo cleanhexo ghexo d Github Pages设置前往Github，找到Hexo项目仓库，点击Setting，往下拉找到Github Pages相关设置，在Custom domain中填入之前注册的域名，点击Save，等十分钟左右，让解析生效，就可以根据域名访问Hexo了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI单元格格式设置]]></title>
    <url>%2F2021%2F11%2F28%2FPOI%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[POI单元格格式设置初始化操作12345678//获取工作簿对象Workbook workbook = new XSSFWorkbook();//获取表格对象Sheet sheet = workbook.createSheet("sheet")//获取单元格样式对象CellStyle cellStyle = worbook.createCellStyle();//获取单元格字体对象Font font = worbook.createFont(); 设置居中对齐12345678910//设置水平对齐的样式为居中对齐; cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);//设置垂直对齐的样式为居中对齐; cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);//POI 3.17的写法//设置水平对齐的样式为居中对齐; cellStyle.setAlignment(HorizontalAlignment.CENTER);//设置垂直对齐的样式为居中对齐; cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); 设置背景色12cellStyle.setFillForegroundColor(IndexedColors.PALE_BLUE.getIndex());cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); 设置边框12345678//设置上边框cellStyle.setBorderTop(BorderStyle.THIN);//设置下边框cellStyle.setBorderBottom(BorderStyle.THIN);//设置左边框cellStyle.setBorderLeft(BorderStyle.THIN);//设置右边框cellStyle.setBorderRight(BorderStyle.THIN); 设置字体12font.setFontName("宋体");cellStyle.setFont(font); 字体加粗12font.setBold(true);cellStyle.setFont(font); 合并单元格123456789101112//CellRangeAddress构造方法四个参数为：初始行、截止行、初始列、截止列CellRangeAddress region = new CellRangeAddress(0,0,0,0);sheet.addMergedRegion(region);//合并单元格后边框不会自动合并，需要额外操作setRegionBorder(BorderStyle.THIN,region,sheet);public static void setRegionBorder(BorderStyle border,CellRangeAddress region,Sheet sheet) &#123; RegionUtil.setBorderTop(border,region,sheet); RegionUtil.setBorderBottom(border,region,sheet); RegionUtil.setBorderLeft(border,region,sheet); RegionUtil.setBorderRight(border,region,sheet);&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot实现文件上传下载]]></title>
    <url>%2F2021%2F11%2F03%2FSpringBoot%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[SpringBoot实现文件上传下载配置在application.yml中添加配置 123456789101112spring: servlet: multipart: enabled: true # 表示是否开启文件上传支持，默认为 true file-size-threshold: 0 # 表示文件写入磁盘的阀值，默认为 0 location: # 表示上传文件的临时保存位置 max-file-size: 1MB # 表示上传的单个文件的最大大小，默认为 1MB max-request-size: 10MB # 表示多文件上传时文件的总大小，默认为 10MBfile: upload: url: E:/test # 上传路径 SpringBoot更改了不同版本的属性名称 SpringBoot 1.3.x及更早 1multipart.max-file-size SpringBoot 1.3.x之后 1spring.http.multipart.max-file-size SpringBoot 2.0之后 1spring.servlet.multipart.max-file-size 文件上传1234567891011121314151617181920212223242526272829303132333435363738394041package com.zmjwdzjl.controller;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletResponse;import java.io.*;@RestController@RequestMapping("file")@Slf4jpublic class FileController &#123; @Value("$&#123;file.upload.url&#125;") private String uploadFilePath; @PostMapping("/upload") public String httpUpload(@RequestParam("files") MultipartFile files[]) &#123; JSONObject object = new JSONObject(); for(int i=0;i&lt;files.length;i++) &#123; // getOriginalFilename方法获取文件名(带后缀)，getName方法获取文件名(不带后缀) String fileName = files[i].getOriginalFilename(); File dest = new File(uploadFilePath +'/'+ fileName); // 判断文件所在目录是否存在，如果不存在就创建对应的目录 if (!dest.getParentFile().exists()) &#123; dest.getParentFile().mkdirs(); &#125; try &#123; // 将文件存放到对应的目录下，如果上传重复的文件不会报错，后上传的文件会覆盖已上传的文件 files[i].transferTo(dest); &#125; catch (Exception e) &#123; log.error("&#123;&#125;",e); object.put("success",2); object.put("result","程序错误，请重新上传"); return object.toString(); &#125; &#125; object.put("success",1); object.put("result","文件上传成功"); return object.toString(); &#125;&#125; 文件下载12345678910111213141516171819202122232425@RequestMapping("/download")public String fileDownLoad(HttpServletResponse response, @RequestParam("fileName") String fileName) &#123; File file = new File(uploadFilePath +'/'+ fileName); if(!file.exists()) &#123; return "下载文件不存在"; &#125; response.reset(); response.setContentType("application/octet-stream"); response.setCharacterEncoding("utf-8"); response.setContentLength((int) file.length()); response.setHeader("Content-Disposition", "attachment;filename=" + fileName ); try(BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file))) &#123; byte[] buff = new byte[1024]; OutputStream os = response.getOutputStream(); int i = 0; while ((i = bis.read(buff)) != -1) &#123; os.write(buff, 0, i); os.flush(); &#125; &#125; catch (IOException e) &#123; log.error("&#123;&#125;",e); return "下载失败"; &#125; return "下载成功";&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis使用Map参数]]></title>
    <url>%2F2021%2F11%2F02%2FMyBatis%E4%BD%BF%E7%94%A8Map%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[MyBatis使用Map参数方法一如果传入的map有注解@Param(“params”)，则key集合可以写成params.keys，value集合可以写成params.values。 123public interface TestMapper &#123; List&lt;String&gt; getList(@Param("params") Map&lt;String, String&gt; params);&#125; 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace=“com.zmjwdzjl.mapper.TestMapper”&gt; &lt;select id="getList" restultType="String" parameterType="java.util.Map"&gt; select id from user &lt;where&gt; &lt;foreach collection="params.keys" item="key" separator="and"&gt; $&#123;key&#125; = #&#123;params.$&#123;key&#125;&#125; -- 或者另一种写法 $&#123;key&#125; = #&#123;params[$&#123;key&#125;]&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 但是这两种方式map中的key只能是String类型，如果是其他类型，得到的value是null。#{params[${key}]}还可以写成${params[key]}。 方法二如果传入的map的key要适用所有类型，可以遍历Map中的entrySet。 123public interface TestMapper &#123; List&lt;String&gt; getList(@Param("params") Map&lt;Long, String&gt; params);&#125; 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace=“com.zmjwdzjl.mapper.TestMapper”&gt; &lt;select id="getList" restultType="String" parameterType="java.util.Map"&gt; select id from user &lt;where&gt; &lt;foreach collection="params.entrySet()" item="value" index="key" separator="or"&gt; id = #&#123;key&#125; and user_name= #&#123;value&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stream为集合添加序号]]></title>
    <url>%2F2021%2F08%2F06%2FStream%E4%B8%BA%E9%9B%86%E5%90%88%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Stream为集合添加序号1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); User u1 = new User(); u1.setUserName("张三"); u1.setPassWord("zhangsan123"); userList.add(u1); User u2 = new User(); u2.setUserName("李四"); u2.setPassWord("lisi123"); userList.add(u2); User u3 = new User(); u3.setUserName("王五"); u3.setPassWord("wangwu123"); userList.add(u3); //遍历添加序号 list.forEach(v -&gt; v.setIndex(list.indexOf(v)+1)); &#125;&#125; @Datapublic class User &#123; private Integer index; private String userName; private String passWord;&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis判断数组和集合的长度]]></title>
    <url>%2F2021%2F08%2F06%2FMyBatis%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[MyBatis判断数组和集合的长度数组12&lt;if test="arr != null and arr.length &gt; 0"&gt;&lt;/if&gt; 集合12345&lt;if test="list != null and list.size() &gt; 0"&gt;&lt;/if&gt;&lt;if test="list != null and !list.isEmpty()"&gt;&lt;/if&gt;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot全局异常处理非法参数]]></title>
    <url>%2F2021%2F08%2F06%2FSpringBoot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B3%95%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Spring Boot全局异常处理非法参数应用场景在一个项目中我们需要对接口中传入的参数进行非法性检查，当参数非法时，抛出异常，然后返回统一的错误信息。 校验注解Bean Validation中内置的校验注解: Constraint 描述 @Null 被注解的元素必须为null @NotNull 被注解的元素必须不为null @AssertTrue 被注解的元素必须为true @AssertFalse 被注解的元素必须为false @Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max,min) 被注解的元素大小必须在指定的范围内 @Digits(integer,fraction) 被注解的元素必须是一个数组，其值必须在可接受的范围内 @Past 被注解的元素必须是一个过去的日期 @Future 被注解的元素必须是一个将来的日期 @Pattern(value) 被注解的元素必须符合指定的正则表达式 Hibernate Validator附加的校验注解: Constraint 描述 @NotBlank 被注解的元素必须非null，且长度必须大于0，并只能作用于String类型的字段上 @Email 被注解的元素必须是电子邮箱地址 @Length(min,max) 被注解的元素大小必须在指定的范围内 @NotEmpty 被注解的元素必须非空 @Range(min,max) 被注解的元素必须在合适的范围内 添加测试Bean添加测试Bean，测试类中定义几个字段，并且每个字段都做一定的限制 1234567891011121314151617181920package com.zmjwdzjl.demo.bean; import lombok.Data;import javax.validation.constraints.NotBlank;import javax.validation.constraints.Pattern;import javax.validation.constraints.Email;@Datapublic class BeanValidation &#123; @Pattern(regexp = "^[A-Za-z0-9]+$",message="只能输入由数字和26个英文字母组成的字符串") private String loginNumber; @NotBlank(message="密码不能为空") private String passWord; @Email(message="邮箱地址格式不正确") private String email; &#125; 添加测试接口在接口中使用@Validated注解对参数进行合法性检查，如果参数合法，返回原始数据 123456@ApiOperation(value = "登录接口")@PostMapping("/login")public Object login(@Validated @RequestBody BeanValidation data) &#123; ResultMsg resultMsg = new ResultMsg(ResultStatusCode.OK.getErrcode(), ResultStatusCode.OK.getErrmsg(), data); return resultMsg;&#125; 添加异常返回类如果未添加全局异常处理，将会使用默认的异常处理，但是返回的结果和自己的数据结构有很大的差异，对于前端处理返回结果也很麻烦。可以自定义参数异常返回的数据类 1234567891011121314package com.zmjwdzjl.demo.bean;import lombok.Data;@Datapublic class ArgumentInvalidResult &#123; private String field; private Object rejectedValue; private String defaultMessage;&#125; 添加全局异常处理1234567891011121314151617181920212223242526272829303132333435package com.zmjwdzjl.demo.exception;import com.sinosoft.batchcommon.domain.RestfulResponse;import com.sinosoft.batchcommon.util.MessageUtils;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import javax.annotation.Resource;import java.util.stream.Collectors;@ControllerAdvice//如果返回的为json数据或其它对象，添加该注解@ResponseBodypublic class GlobalExceptionHandler &#123; //添加全局异常处理流程，根据需要设置需要处理的异常，本文以MethodArgumentNotValidException为例 @ExceptionHandler(value = MethodArgumentNotValidException.class) public Object MethodArgumentNotValidHandler(MethodArgumentNotValidException exception) &#123; //按需重新封装需要返回的错误信息 List&lt;ArgumentInvalidResult&gt; invalidArguments = new ArrayList&lt;&gt;(); //解析原错误信息，封装后返回，此处返回非法的字段名称，原始值，错误信息 for (FieldError error : exception.getBindingResult().getFieldErrors()) &#123; ArgumentInvalidResult invalidArgument = new ArgumentInvalidResult(); invalidArgument.setDefaultMessage(error.getDefaultMessage()); invalidArgument.setField(error.getField()); invalidArgument.setRejectedValue(error.getRejectedValue()); invalidArguments.add(invalidArgument); &#125; ResultMsg resultMsg = new ResultMsg(ResultStatusCode.PARAMETER_ERROR.getErrcode(), ResultStatusCode.PARAMETER_ERROR.getErrmsg(), invalidArguments); //也可以用stream将异常信息拼接成字符串返回 String msg = String.join("\n",exception.getBindingResult().getFieldErrors().stream().map(error-&gt;error.getField+":"+error.getRejectedValue+"捕获异常:"+error.getDefaultMessage()).collect(Collectors.toList())); return resultMsg; &#125;&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring项目定制启动图案]]></title>
    <url>%2F2021%2F08%2F06%2FSpring%E9%A1%B9%E7%9B%AE%E5%AE%9A%E5%88%B6%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Spring项目定制启动图案介绍在Spring Boot项目启动的时候会显示一个默认的Spring的图案，对应的类为SpringBootBanner 1234567. ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.6.RELEASE) 图案的输出方式有以下几种模式，默认是CONSOLE的，即只打印到控制台 123456789101112131415161718enum Mode &#123; /** * Disable printing of the banner. */ OFF, /** * Print the banner to System.out. */ CONSOLE, /** * Print the banner to the log file. */ LOG&#125; 关闭图案关闭图案需要在启动类的main方法中加入以下代码 123public static void main(String[] args) &#123; new SpringApplicationBuilder(DemoApplication.class).bannerMode(Banner.Mode.OFF).run(args);&#125; 或者使用配置文件修改，在application.yml文件中加入以下代码 123spring: main: banner-mode: console 定制图案在项目下的src/main/resources 目录下新建一个banner.txt 即可 图案可以到banner生成网站生成，然后拷贝到文件中即可 也可以通过配置文件来定制图案 12345678# BANNERbanner.charset=UTF-8 # Banner file encoding.banner.location=classpath:banner.txt # Banner file location.banner.image.location=classpath:banner.gif # Banner image file location (jpg/png can also be used).banner.image.width= # Width of the banner image in chars (default 76)banner.image.height= # Height of the banner image in chars (default based on image height)banner.image.margin= # Left hand image margin in chars (default 2)banner.image.invert= # If images should be inverted for dark terminal themes (default false)]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python获取版本号]]></title>
    <url>%2F2021%2F08%2F06%2FPython%E8%8E%B7%E5%8F%96%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Python获取版本号12import platformprint(platform.python_version())]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch解决Result window is too large, from + size must be less than or equal to: [10000] but was [10025]问题]]></title>
    <url>%2F2021%2F08%2F06%2FElasticsearch%E8%A7%A3%E5%86%B3Result-window-is-too-large-from-size-must-be-less-than-or-equal-to-%5B10000%5D-but-was-%5B10025%5D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Elasticsearch解决Result window is too large, from + size must be less than or equal to: [10000] but was [10025]问题问题描述在使用Elasticsearch做分页查询时，当查询记录超过10000时，会报如下错误 1Result window is too large, from + size must be less than or equal to: [10000] but was [10025]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level parameter. 查阅文档可知，默认只能查询到10000 12index.max_result_windowThe maximum value of from + size for searches to this index. Defaults to 10000. Search requests take heap memory and time proportional to from + size and this limits that memory. See Scroll or Search After for a more efficient alternative to raising this. 解决办法修改索引index的max_result_window属性，设置最大返回结果的大小 1234put http://10.127.0.1:9200/test/_settings&#123; "index.max_result_window":1000001&#125; 修改成功后返回 123&#123; "acknowledged": true&#125;]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储emoji表情]]></title>
    <url>%2F2020%2F10%2F03%2FMySQL%E5%AD%98%E5%82%A8emoji%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[MySQL存储emoji表情Background在使用字符集是UTF-8的MySQL数据库存储emoji表情时，会抛出异常（如微信开发获取用户昵称，有的用户的昵称是emoji的图像） Exception123456789java.sql.SQLException: Incorrect string value: '\xF0\x9F\x92\x94' for colum n 'name' at row 1 at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1073) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3593) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3525) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1986) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2140) at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2620) at com.mysql.jdbc.StatementImpl.executeUpdate(StatementImpl.java:1662) at com.mysql.jdbc.StatementImpl.executeUpdate(StatementImpl.java:1581) Whyemoji表情是1个字符占4个字节，而UTF-8编码只支持1-3个字节的字符，所以UTF-8编码下，如果直接存储表情，数据库存储会失败 How修改table的字符集 1ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; utf8mb4完全向后兼容utf8，无乱码或其他数据丢失的形式出现。理论上是可以放心修改，如果您不放心修改，您可以拿备份恢复数据]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>emoji</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调用List的方法抛出UnsupportedOperationException]]></title>
    <url>%2F2020%2F10%2F03%2F%E8%B0%83%E7%94%A8List%E7%9A%84%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BAUnsupportedOperationException%2F</url>
    <content type="text"><![CDATA[调用List的方法抛出UnsupportedOperationExceptionBackground使用Arrays.asList方法将数组转化成List集合后调用List的方法抛出UnsupportedOperationException异常。 Exception12345java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) at java.util.AbstractList$Itr.remove(AbstractList.java:374) at java.util.AbstractCollection.remove(AbstractCollection.java:293) at com.synnex.order.search.service.dao.DemoTest.test7(DemoTest.java:140) WhyArrays.asList方法重新new了一个ArrayList, 但是这个ArrayList不是来自于util包下面的ArrayList， 而是Arrays类里面的内部静态类。这个内部静态类继承AbstractList, 但是没有重写add() , remove()等方法， 所以在调用add(). remove()等方法的时候，实际调用的是AbstractList类的add()和remove()的方法，因此会抛出异常。 How1234String[] testArr = &#123;"Tom","Jerry","Dave"&#125;;List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(Arrays.asList(testArr));stringList.remove("Tom");System.out.println(stringList);]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAop配合自定义注解]]></title>
    <url>%2F2020%2F09%2F19%2FSpringAop%E9%85%8D%E5%90%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SpringAop配合自定义注解什么是AOPAOP全称Aspect Oriented Programming，也就是面向切面编程。AOP主要实现的是针对业务处理过程中的切面进行提取，能够让我们在不影响原有业务功能的前提下，横切扩展新的功能。它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。 AOP相关术语要理解Spring Boot整合AOP的实现，就必须先对面向切面实现的一些AOP术语有所了解。在Spring的AOP中有很多的术语，而且容易混淆，大家一定要先搞清楚这几个概念： 切面（Aspect）：一个关注点的模块化，由切点和通知组成。以注解@Aspect的形式放在类上方，用来声明切面。 连接点（Joinpoint）：在程序执行过程中某个特定的点，比如类初始化前、类初始化后，方法调用前，方法调用后。 切点（Pointcut）：切点就是你所切取的类中的方法，比如你横切的这个类中有两个方法，那么这两个方法都是连接点，对这两个方法的定位就称之为切点。以注解@Pointcut的形式，使用条件表达式定义切点。 通知（Advice）：需要完成的工作叫做通知，比如业务逻辑中的事务、日志等先定义好，然后在需要的地方去用。 主要包括5个注解：Before、After、AfterReturning、AfterThrowing、Around。 @Before：前置增强，在切点方法之前执行。 @After：最终增强，在切点方法之后执行。 @AfterReturning：后置增强，在切点方法退出时执行。 @AfterThrowing：在切点方法抛出异常时执行。 @Around：环绕增强，能控制切点执行前，执行后，用这个注解后，程序抛异常，会影响@AfterThrowing这个注解。 织入（Weaving）：织入就是将通知逻辑添加到目标对象的过程。 目标对象（Target）：通知逻辑织入的目标类，就是通知逻辑植入到什么位置。 引介（Introduction）：一种特殊的通知，它可以在不改变一个现有类代码的情况下，为该类添加属性和方法。把切面定义的用到目标类中去。 代理（Proxy）：一个类被AOP织入通知后，就会产生一个结果类，他是融合了原类和通知逻辑的代理类。 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 自定义注解作用在反射中获取注解，以取得注解修饰的类、方法或属性的相关解释。 注解代码1234567891011package com.istuadmission.common.annotation;import java.lang.annotation.*;@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)//使用位置（类，方法）@Retention(RetentionPolicy.RUNTIME)//加载到jvm里运行@Documented//文档化public @interface Log &#123; String value() default "";//注解的属性，如果只有一个属性，一般叫value，默认值""，可以不写 String name() default "验证名称";&#125; 使用注解12345@Log(value = "vale", name = "name") //与其它注解一样的使用@RequestMapping(value = "/add", method = RequestMethod.POST)public String add() &#123; return "test";&#125; 创建AOP切面作用定义好注解后，需要解析类来实现，此处使用AOP来实现。 切面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.istuadmission.common.aspect;import com.istuadmission.common.annotation.Log;import com.istuadmission.common.service.LogService;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.lang.reflect.Method;@Aspect//定义切面@Componentpublic class LogAspect &#123; @Resource private LogService logService; //定义切入点 @Pointcut("@annotation(com.istuadmission.common.annotation.Log)") public void logPointCut() &#123; &#125; //添加环绕通知@Around @Around("logPointCut()") public void around(ProceedingJoinPoint point) throws Throwable &#123; //先执行切点方法，再执行切面方法，放到最后就是先执行切面，再执行切点 Object result = point.proceed(); //获得切点的类名 String targetName = joinPoint.getTarget().getClass().getName(); //获得切点的方法名 String methodName = joinPoint.getSignature().getName(); //获取切点方法的所有入参 Object[] args = point.getArgs(); //通过Method对象获取切点方法的关键信息，类，包 MethodSignature signature = (MethodSignature) point.getSignature(); Method method = signature.getMethod(); Log log = method.getAnnotation(Log.class); if (log != null) &#123; logService.insert(log.value(),log.name()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot后台国际化]]></title>
    <url>%2F2020%2F09%2F13%2FSpringBoot%E5%90%8E%E5%8F%B0%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SpringBoot后台国际化新建国际化资源文件在resources下面新建了三个文件 messages.properties是必须的，内容可以为空，但是必须有这个文件 messages_zh_CN.properties和messages_en_US.properties分别是中文和英文资源 配置国际化如果是从请求头中获取Local Message 123456789101112131415161718192021222324import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver;import javax.servlet.http.HttpServletRequest;import java.util.Locale;@Configurationpublic class LocaleConfig extends AcceptHeaderLocaleResolver implements WebMvcConfigurer &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String headerLang = request.getHeader("language"); return headerLang == null || headerLang.isEmpty() ? Locale.CHINESE : new Locale(headerLang); &#125; @Bean public LocaleResolver localeResolver()&#123; return new LocaleConfig(); &#125;&#125; 如果是从HTTP请求中参数Local Message 12345678910111213141516171819202122232425262728293031323334353637import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import java.util.Locale;@Configurationpublic class LocaleConfig &#123; /** * 默认解析器 其中locale表示默认语言 */ @Bean public LocaleResolver localeResolver() &#123; SessionLocaleResolver localeResolver = new SessionLocaleResolver(); localeResolver.setDefaultLocale(Locale.CHINESE); return localeResolver; &#125; /** * 默认拦截器 其中lang表示切换语言的参数名 */ @Bean public WebMvcConfigurer localeInterceptor() &#123; return new WebMvcConfigurer() &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; LocaleChangeInterceptor localeInterceptor = new LocaleChangeInterceptor(); localeInterceptor.setParamName("lang"); registry.addInterceptor(localeInterceptor); &#125; &#125;; &#125;&#125; 编写工具类获取Local Message12345678910111213141516171819import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.context.i18n.LocaleContextHolder;import org.springframework.stereotype.Component;@Componentpublic class MessageUtils &#123; @Autowired private MessageSource messageSource; public String getLocale(String msgCode) &#123; try &#123; return messageSource.getMessage(msgCode, null, LocaleContextHolder.getLocale()); &#125; catch (Exception e) &#123; return msgCode; &#125; &#125;&#125; 使用在REST API中使用 123456789101112@RestController@RequestMapping("/TestController")public class TestController &#123; @Resource private MessageUtils messageUtils; @PostMapping("/test") public String test() &#123; return messageUtils.getLocale("test"); &#125;&#125; 测试 如果出现中文乱码的情况 在Settings中将编码格式改成UTF-8 然后将乱码的文字重新编写一下就好了]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>国际化</tag>
        <tag>i18n</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后台运行与停止jar包]]></title>
    <url>%2F2020%2F09%2F05%2F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%81%9C%E6%AD%A2jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[后台运行与停止jar包后台运行jar包命令1nohup java -jar jar包名 &amp; nohup：加在一个命令的最前面，表示不挂断的运行命令 &amp;：加载一个命令的最后面，表示这个命令放在后台执行 后台停止 找到进程号 1ps aux|grep jar包名 杀死进程 1kill -9 进程号(红框标记的进程号) kill -9是操作系统从内核级别强制杀死一个进程，如果希望正常退出进程可以使用kill -15]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git修改查看用户名和邮箱]]></title>
    <url>%2F2020%2F08%2F30%2FGit%E4%BF%AE%E6%94%B9%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[Git修改查看用户名和邮箱修改用户名和邮箱12$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;email&quot; 查看用户名和邮箱12$ git config user.name$ git config user.email]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5加密]]></title>
    <url>%2F2019%2F11%2F07%2FMD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[MD5加密MD5加密后转为小写16进制12345678910111213141516171819202122232425public static String Md5(String plainText) &#123; StringBuffer buf = new StringBuffer(""); String result; try &#123; MessageDigest md = MessageDigest.getInstance("MD5"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i; for (int offset = 0; offset &lt; b.length; offset++) &#123; i = b[offset]; if (i &lt; 0) i += 256; if (i &lt; 16) buf.append("0"); buf.append(Integer.toHexString(i)); &#125; byte[] bytes = new String(buf).getBytes(); result = DatatypeConverter.printHexBinary(bytes); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; return result; &#125; MD5加密后转为小写32进制12345678910111213141516171819202122public static String encryption(String plainText) &#123; String re_md5 = new String(); try &#123; MessageDigest md = MessageDigest.getInstance("MD5"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(""); for (int offset = 0; offset &lt; b.length; offset++) &#123; i = b[offset]; if (i &lt; 0) i += 256; if (i &lt; 16) buf.append("0"); buf.append(Integer.toHexString(i)); &#125; re_md5 = buf.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return re_md5; &#125;]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next使用Valine作评论系统]]></title>
    <url>%2F2019%2F08%2F29%2FHexo-Next%E4%BD%BF%E7%94%A8Valine%E4%BD%9C%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Hexo Next使用Valine作评论系统注册LeanCloud前往LeanCloud进行注册登陆 创建应用点击创建应用 输入应用名称(名称随意), 选择开发版, 点击创建 配置应用创建成功后点击应用右上角的设置 点击存储，创建Class，Class名称设置为Comment(必须为Comment)，选择无限制，点击创建 创建后点击设置，点击应用Key，获取App ID和App Key 修改主题配置文件将主题配置文件/themes/next/_config.yml中的Valine:的enable设为true，并将App ID和App Key填入 配置域名点击安全中心, 填写自己博客对应的域名（注意协议、域名和端口号需严格一致） 启动Hexo完成后执行hexo clean和hexo s启动Hexo,打开文章便可以看到评论了 好了，到此Hexo Next使用Valine作评论系统就完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置侧边栏社交小图标]]></title>
    <url>%2F2019%2F08%2F29%2FHexo%E8%AE%BE%E7%BD%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%A4%BE%E4%BA%A4%E5%B0%8F%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[Hexo设置侧边栏社交小图标修改主题配置文件在主题配置文件里找到social_icons，将enable修改为true,并将链接写入 启动Hexo启动Hexo后，便可以看到侧边栏已显示社交小图标 好了，到此Hexo设置侧边栏社交小图标就安装成功了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置首页不显示文章全文]]></title>
    <url>%2F2019%2F08%2F28%2FHexo%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[Hexo设置首页不显示文章全文修改主题配置文件在主题配置文件_config.yml文件中，找到如下： 将enable改成true就可以了在首页启动显示文章预览了 length是显示预览的长度。 启动Hexo 好了，到此Hexo设置首页不显示原文就安装成功了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next添加本地搜索功能]]></title>
    <url>%2F2019%2F08%2F28%2FHexo-Next%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo Next添加本地搜索功能安装本地搜索插件在站点目录下执行npm install hexo-generator-search --save安装本地搜索插件 修改站点配置文件在站点配置文件 _config.yml中添加如下内容 12345search: path: search.xml field: post format: html limit: 10000 path：索引文件的路径，相对于站点根目录 field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面 limit：限制搜索的条目数 修改主题配置文件在主题配置文件_config.yml中找到如下内容： 1234local_search: enable: false trigger: auto top_n_per_article: 1 将enable设成true top_n_per_article 字段表示在每篇文章中显示的搜索结果数量，设成 -1 会显示每篇文章的所有搜索结果数量。 更改后如下 启动Hexo启动后便可以在侧边栏看到本地搜索功能了 好了，到此Hexo添加本地搜索功能就成功了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加打赏功能]]></title>
    <url>%2F2019%2F08%2F28%2FHexo%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo添加打赏功能修改主题配置文件在主题配置文件中，找到reward_comment，将其修改为 123reward_comment: 如果对您有帮助，可以打赏哟！wechatpay: 图片链接或图片相对路径alipay: 图片链接或图片相对路径 如下图所示 启动Hexo启动hexo后，打开文章就可以看到了 好了，到此Hexo添加打赏功能就成功了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加RSS]]></title>
    <url>%2F2019%2F08%2F28%2FHexo%E6%B7%BB%E5%8A%A0RSS%2F</url>
    <content type="text"><![CDATA[Hexo添加RSS安装RSS插件在站点目录下执行npm install hexo-generator-feed --save安装RSS插件 修改站点配置文件在站点目录下的配置文件_config.yml中，加入以下配置 1234feed: type: atom path: atom.xml limit: 20 修改主题配置文件主题目录下的配置文件_config.yml文件中，将RSS设置为/atom.xml 1rss: /atom.xml 启动Hexo启动后就能看到RSS已经显示 好了，到此Hexo添加RSS功能就完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next统计文章访问量]]></title>
    <url>%2F2019%2F08%2F27%2FHexo-Next%E7%BB%9F%E8%AE%A1%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Hexo Next统计文章访问量注册LeanCloud前往LeanCloud进行注册登陆 创建应用点击创建应用 输入应用名称(名称随意), 选择开发版, 点击创建 配置应用创建成功后点击应用右上角的设置 点击存储，创建Class，Class名称设置为Counter(必须为Counter)，选择无限制，点击创建 创建后点击设置，点击应用Key，获取App ID和App Key 修改主题配置文件将主题配置文件/themes/next/_config.yml中的leancloud_visitors:的enable设为true，并将App ID和App Key填入 配置域名点击安全中心, 填写自己博客对应的域名（注意协议、域名和端口号需严格一致） 启动Hexo完成后执行hexo clean和hexo s启动Hexo,便可以看到访问量标志了 好了，到此Hexo Next添加统计文章访问量功能就完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo生成tag和categories]]></title>
    <url>%2F2019%2F08%2F27%2FHexo%E7%94%9F%E6%88%90tag%E5%92%8Ccategories%2F</url>
    <content type="text"><![CDATA[Hexo生成tag和categories添加标签页面打开cmd，进入站点目录下 执行hexo new page tags生成标签页 在source/tags/index.md文件中添加type: “tags”，注意：记得type:后面有空格 添加分类页面执行hexo new page categories生成分类页 在source/categories/index.md文件中添加type: “categories”，注意：记得type:后面有空格 设置菜单栏在themes\next主题目录下的_config.yml文件中找到menu，将tag和categories加入 引入tags和categories在文章中引入tags和categories 启动hexo后就可以看到tags和categories已经显示了 好了，到此Hexo生成tag和categories就完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECS上搭建Docker]]></title>
    <url>%2F2019%2F08%2F26%2FECS%E4%B8%8A%E6%90%AD%E5%BB%BADocker%2F</url>
    <content type="text"><![CDATA[ECS上搭建Docker检查版本执行uname -r检查系统的发行版号 若版本低于3.10.0，执行yum update升级系统 中途出现是否下载，输入y 若出现Complete!则升级安装成功 安装Docker执行yum install docker安装Docker 中途出现是否下载，输入y 若出现Complete!则Docker安装结束 执行docker -v查看是否安装成功 执行systemctl start docker启动Docker 执行systemctl status docker查看Docker状态，若显示running则启动成功 执行systemctl enable docker设置Docker开机自启 安装JDK执行docker search openjdk查找JDK镜像 执行docker pull openjdk拉取JDK镜像 执行docker images查看镜像列表，若出现openjdk则拉取成功 执行docker run -d -it --name myopenjdk openjdk创建JDK容器 执行docker ps -a查看容器列表，若出现openjdk容器则创建成功 安装Tomcat执行docker search tomcat查找Tomcat镜像 执行docker pull tomcat拉取Tomcat镜像 执行docker images查看镜像列表，若出现Tomcat则拉取成功 执行docker run -d -p 8080:8080 --name mytomcat tomcat创建Tomcat容器 执行docker ps -a查看容器列表，若出现Tomcat容器则创建成功 查看8080端口，若出现下图则Tomcat安装成功 安装MySQL执行docker search mysql查找MySQL镜像 执行docker pull mysql拉取MySQL镜像 执行docker images查看镜像列表，若出现MySQL则拉取成功 执行docker run -p 3306:3306 --name MySQL -e MYSQL_ROOT_PASSWORD=root -d mysql创建MySQL容器，注意：MYSQL_ROOT_PASSWORD=root是设置MySQL密码，可以将root替换成自己的密码 执行docker ps -a查看容器列表，若出现MySQL容器则创建成功 执行docker exec -it [CONTAINER ID] bash进入MySQL容器，注意：[CONTAINER ID]替换为自己MySQL容器的CONTAINER ID 执行mysql -u root -p登录MySQL 输入MySQL密码，若密码正确则登录成功 执行use mysql选择mysql数据库 执行ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;设置为mysql_native_password，注意：BY后面为MySQL密码，若不想更改密码则将root改为原有密码 执行exit;退出MySQL 执行exit退出MySQL容器 使用Navicat测试MySQL是否可使用 点击连接测试，若弹出连接成功则MySQL安装成功 安装Redis执行docker search redis查找Redis镜像 执行docker pull redis拉取Redis镜像 执行docker images查看镜像列表，若出现Redis则拉取成功 执行docker run -d -p 6379:6379 --name myredis redis创建Redis容器 执行docker ps -a查看容器列表，若出现Redis容器则创建成功 使用RedisDesktopManager测试Redis是否可使用 点击测试连接，若弹出连接Redis服务器成功则Redis安装成功 安装 RabbitMQ执行docker search rabbitmq查找RabbitMQ镜像 执行docker pull rabbitmq:3-management拉取RabbitMQ镜像 执行docker images查看镜像列表，若出现RabbitMQ则拉取成功 执行docker run -d -p 5672:5672 -p 15672:15672 --name myrabbit [IMAGE ID]创建RabbitMQ容器，注意：[IMAGE ID]用自己的IMAGE ID替换 执行docker ps -a查看容器列表，若出现RabbitMQ容器则创建成功 查看8080端口，若出现下图则RabbitMQ安装成功 好了，到此我们的Docker搭建教程就完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置Next主题]]></title>
    <url>%2F2019%2F08%2F22%2FHexo%E9%85%8D%E7%BD%AENext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo配置Next主题安装NexT在其文件夹中鼠标右键,点击Git Base Here 输入命令git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在站点目录中（blog），打开配置文件_config.yml，将theme修改为next 启动服务 如果看到如下界面，说明成功安装了NexT主题 主题设定在themes\next主题目录下的_config.yml文件中将scheme设定为Pisces 语言设定在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文），可根据个人喜好修改语言 设置侧栏位置修改主题目录下配置文件_cofig.yml中sidebar的position值,可根据个人喜好修改侧栏位置 设置头像在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在站点根目录下的source/images/ 目录下） 设置文章代码主题在主题目录下修改配置文件中的highlight_theme，默认值为nomal。可以设置为night，根据个人喜好修改文章代码主题 修改作者头像并旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 好了，到此为止，我们的Hexo配置Next主题就已经完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github搭建博客]]></title>
    <url>%2F2019%2F08%2F21%2F%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Hexo+Github搭建博客安装Node.js和配置Node.js环境，打开cmd命令行，输入node -v和npm -v若安装成功则显示如下信息 安装Git和配置Git环境，若右键出现以下选择则表示安装成功 一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 注册Github账户并新建项目项目必须要遵守格式：账户名.github.io，并且勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击进入 向下找到GitHub Pages，你会看到有个网址，访问它，你会发现该项目已经被部署到网络上，能够通过外网来访问它。 新建一个文件夹，然后通过命令行进入到该文件夹 输入npm install hexo -g安装Hexo 输入hexo -v检查hexo是否安装成功，若成功则出现以下信息 输入hexo init初始化项目，若出现“Start blogging with Hexo！”则表示初始化成功 输入npm install安装依赖 输入hexo g生成静态文件 输入hexo s启动Hexo 如果页面一直无法跳转，那么可能是端口被占用了。ctrl+c停止服务器，输入hexo server -p 端口号改变端口号 如果出现下图则表示成功了 将Hexo与Github page联系起来如果是第一次使用Git的话，需要设置Git的user name和email在blog文件目录下点击Git Base Here，输入git config --global user.name &quot;gao&quot;和git config --global user.email &quot;851861663@qq.com&quot;设置用户名和邮箱，这里用户名和邮箱可以替换成自己 输入cd ~/.ssh，检查是否有.ssh的文件夹 输入ls，列出该文件下的内容，若出现下图怎说明文件存在 输入ssh-keygen -t rsa -C &quot;851861663@qq.com&quot;连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh） 输入eval &quot;$(ssh-agent -s)&quot;添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings 点击SSH and GPG keys 点击new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com测试添加ssh是否成功,如果看到Hi后面是你的用户名，就说明成功了 假如ssh-key配置失败，需要执行一下步骤清除所有的key-pairssh-add -Drm -r ~/.ssh 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来继续之前的操作 配置Deployment，在blog文件夹中，找到_config.yml文件，在末尾修改repo值 注意：每个变量的：后面都要有空格 repo值是你在github项目里的ssh（右下角） 新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，还需要执行npm install hexo-deployer-git --save 编辑好文章后，就可以执行hexo d -g生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 好了，到此为止，hexo+github博客的搭建就已经完成了]]></content>
      <categories>
        <category>搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装教程]]></title>
    <url>%2F2019%2F08%2F10%2FMySQL%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[MySQL 8.0.16安装教程(windows 64位)MySQL官网下载地址点击下载Windows 64位正式版 点击No Thanks,just start my download 便可以下载 下载完成后解压，解压后的目录 解压后的目录中没有my.ini文件，在安装根目录下自行创建my.ini（新建文本文件，将文件类型改为的.ini），写入基本配置：12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=C:\Program Files\MySQL# 设置mysql数据库的数据的存放目录datadir=C:\Program Files\MySQL\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4 配置文件中的路径要和实际存放的路径一致 在安装时，为避免出错使用管理员身份运行CMD，否则在安装时会报错，会导致安装失败的情况（进入C:\Windows\System32，右键cmd.exe以管理员身份运行） 打开CMD后进入mysql的bin目录 在MySQL目录下的bin目录下执行命令：mysqld --initialize --console [注意] 红框为root@localhost生成临时密码：9P0gYk-？0，kT，在没有更改密码前，需要记住这个密码，后续登录需要用到。复制密码先保存起来!!! 执行mysqld --install 命令，安装mysql服务 如果出现红框表示MySQL服务安装成功了， 如果出现下图则说明mysql的服务已存在，需要把它删掉 执行sc delete mysql命令，删除MySQL，再执行mysqld --install安装服务命令 服务安装成功之后，执行net start mysql命令启动MySQL服务 执行mysql -u root -p命令登录mysql，密码为之前的临时密码 执行ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;命令修改mysql密码，new pasword为修改后的密码 若显示Query OK,0 rows affected即为修改成功 好了，到此为止，MySQL就已经安装完毕了]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK安装与环境变量配置]]></title>
    <url>%2F2019%2F07%2F14%2FJDK%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[JDK12安装与环境变量配置jdk是学习java必不可少的，以Win10 64位系统和大家分享一下jdk12的下载和安装。有需要的朋友可以参考下。 JDK官网下载地址 点击 Accept License Agreement，根据自己的电脑(32位还是64位)选择对应的版本下载。 下载完成后，运行”.exe”文件，开始安装]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
</search>
